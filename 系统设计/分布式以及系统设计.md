# 分布式系统
分布式系统就是把好多个小模块放在不同的主机上 ，然后用户是感觉不到他们分开的，感觉到是一个整体。
> AMS就是一个分布式系统。

### 分布式如何实现的呢：

- load balance:
- 多个node;
- 每个node可能有多个不同系统的instance
- 使用MQ，不同node是consumer；



### 分布式的好处：
- Disaster recovery，一个挂了还有另一个； 
- 并发多进程处理，提高效率 
- 灵活，哪个模块瓶颈了就加node;
- 一个主机并不是有全部的系统，一个主机可以开多node也可以停，降低耦合性，然后灵活，utilise资源。


### 分布式缓存： 

#### 为什么要用缓存：
- 1: 缩短系统的响应时间，提升用户体验， 缓存快
- 2: 扛住更大的流量，保护关键系统组件。举个例子在高并发，大流量的场景下如果没有缓存的保护，所有的请求的都直接穿透到我们底层的DB。DB基本上都是扛不住的，DB一旦宕机基本上整个系统就over了，但很多缓存中间件比如redis,memcache却可以扛得住
- 3: 提升整体的吞吐

#### 缓存的分类
- 集中式缓存，本地缓存，分布式缓存
- 集中式缓存： 所有的缓存都统一在一个地方管理， 一致性好，实时性好， 但是都放在一个地方， 大吞吐有瓶颈
- 本地缓存： 性能好，但会存在不一致性问题 , 可能导致一个节点update进来了，另一个节点的缓存却没有更新，（所以需要invalid cache 不能 update cache）,必须给本地缓存加上一个过期失效时间，并且建立一套相对**实时数据更新机制，保证副本的数据能够有效及时更新** 比如当key有更新，通知所有的节点invalid cache. 例如 google guava
- 分布式缓存比如redis

#### 缓存的一些特征
- 命中率： 返回正确结果数/请求缓存次数，命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高
- 最大空间， 可以存放最大的缓存元素数量， 很多情况下通过LRU，LFU决定如何清理缓存

#### 缓存的一致性
- 一般可能由于网络的不稳定或者节点的故障，导致一些不一致性
- 如果**先写缓存，再写数据库**，可能导致缓存写成功，但是写数据库的时候响应失败，下次读取缓存会**脏读**， 这个方式是错误的
- **先写数据库，再写缓存**，会导致下一次读不到数据（降低效率但是不会脏读），如何解决需要看实际情况，可以在下一次使用缓存的时候，如果读取缓存失败，就读数据库，在读的时候把缓存回写。



### 如何控制分布式的一致性：
- load balance： 一个访问请求被一个node拿到；

> 问题（如果一个节点拿到了data但是却坏了，这个时候已经把message consume了 怎么办）？

- DB加锁。（秒杀一类的）；
- 乐观锁，用version number来保证；  


### 如果在不同的DB，我们有需要保持事务的一致性，我们怎么办呢？ 
- 两阶段提交算法 :

>  比如我发请求给ABCD四个NODE。AB成功，CD挂掉了。 我需要AB也roll back。
	这个情况我需要两步，第一步发给ABCD，ABCD存储上一次的结果。ABCD return给发送者回应是否成功。
	只有当发送者接到成功的消息，发送者发第二次请求进行commit。 
	任何收不到或者受到错误，滚回。


```		
	阶段1：请求阶段（commit-request phase，或称表决阶段，voting phase）。
	在请求阶段，协调者将通知事务参与者准备提交或取消事务，
	然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。
	
```	

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/%20%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A4.jpg" style="height:190px" />

```	
	阶段2：提交阶段（commit phase）。
	在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
	当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
	参与者在接收到协调者发来的消息后将执行响应的操作

```
<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A42.jpg" style="height:190px" />



## Load balance 的算法：

#### 轮询（Round Robin）
- 轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求  按 (1, 2, 3, 4, 5, 6) 的顺序发送。 最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 


<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/roundRobin.jpg" style="height:300px" />

- 这样存在一个问题，只能适用于性能差不多的服务器, 如果另一个服务器的性能较差，就不可以了

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/badRoundRobin.jpg" style="height:300px" />

#### 加权轮询（Weighted Round Robbin）； 根据服务器效率的配比；

- 加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/加权轮询.jpg" style="height:300px" />


#### 最少连接（least Connections） 将请求发给现在有最少连接的；
- 由于每个请求的链接时间不一样，使用加权轮询或者轮询可能会让一台服务器的链接过大而另一台很少，造成不均衡
- 最少链接法就是将请求发送给最少链接的服务器上，如下图，服务器1当前连接数最少，新来的请求6就会发送到服务器1上面

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/最小链接.jpg" style="height:300px" />



#### 最少加权连接（Weighted Least Connection） 将请求发给现在有最少连接的；

- 在最小连接的基础上，根据服务器的性能为每台服务器分配权重，根据权重计算出每台服务器能处理的连接数

#### 随机链接


#### 实现 1：使用 DNS 作为负载均衡器
- DNS服务器上配置多个域名对应IP的记录， 根据负载情况返回不同服务器的 IP 地址
- 是进行域名(domain name)和与之相对应的IP地址(IP address)转换的服务器。 DNS中保存了一张域名(domain name)和与之相对应的IP地址(IP address)的表，以解析消息的域名
- 这样可以通过映射关系，把请求的地址进行对相应服务器的分配
- 例如一个域名www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。
- 因为是映射关系，不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。

#### 实现 2：http 重新定向
- 根据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问
- 例如访问 114.100.110.200 load balancer  -> 然后我们会根据服务度端的情况，redirect 去114.100.110.210
- 浏览器需要每次请求服务器才能完成一次访问，性能较差, 优点是简单

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/httprediect.jpg" style="height:300px" />


- 类似的做法是修改访问IP地址

#### 实现3 ： 反向代理 ？？？
- jianshu.com/p/208c02c9dd1d
- https://juejin.im/entry/5af135416fb9a07ab77427b5
- https://cloud.tencent.com/developer/article/1595214


# Redis

### Redis 数据类型

- Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合 

### Redis Hash

- Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象







- 保证消息具有唯一编号，可以通过日志进行backtrace。
