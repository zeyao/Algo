# 分布式系统
分布式系统就是把好多个小模块放在不同的主机上 ，然后用户是感觉不到他们分开的，感觉到是一个整体。
> AMS就是一个分布式系统。

### 分布式如何实现的呢：

- load balance:
- 多个node;
- 每个node可能有多个不同系统的instance
- 使用MQ，不同node是consumer；



### 分布式的好处：
- Disaster recovery，一个挂了还有另一个； 
- 并发多进程处理，提高效率 
- 灵活，哪个模块瓶颈了就加node;
- 一个主机并不是有全部的系统，一个主机可以开多node也可以停，降低耦合性，然后灵活，utilise资源。

### 本地缓存
- Google gavua 缓存
- 本地缓存请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适
- 多节点之间每个节点都需要独立的应用，对内存是一种浪费
### 分布式缓存： 

#### 为什么要用缓存：
- 1: 缩短系统的响应时间，提升用户体验， 缓存快
- 2: 扛住更大的流量，保护关键系统组件。举个例子在高并发，大流量的场景下如果没有缓存的保护，所有的请求的都直接穿透到我们底层的DB。DB基本上都是扛不住的，DB一旦宕机基本上整个系统就over了，但很多缓存中间件比如redis,memcache却可以扛得住
- 3: 提升整体的吞吐

#### 缓存的分类
- 集中式缓存，本地缓存，分布式缓存
- 集中式缓存： 所有的缓存都统一在一个地方管理， 一致性好，实时性好， 但是都放在一个地方， 大吞吐有瓶颈
- 本地缓存： 性能好，但会存在不一致性问题 , 可能导致一个节点update进来了，另一个节点的缓存却没有更新，（所以需要invalid cache 不能 update cache）,必须给本地缓存加上一个过期失效时间，并且建立一套相对**实时数据更新机制，保证副本的数据能够有效及时更新** 比如当key有更新，通知所有的节点invalid cache. 例如 google guava
- 分布式缓存比如redis

#### 缓存的一些特征
- 命中率： 返回正确结果数/请求缓存次数，命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高
- 最大空间， 可以存放最大的缓存元素数量， 很多情况下通过LRU，LFU决定如何清理缓存

#### 缓存的一致性
- 一般可能由于网络的不稳定或者节点的故障，或者并发，导致一些不一致性

- 策略： **读的时候读到了数据库但是没有命中缓存的话，这时写缓存；写的时候先写数据库，写完以后清除缓存， 注意顺序和是清除，而不是更新**；

- **先写数据库，再清除缓存**，会导致下一次读不到数据，可以在下一次**读缓存**的时候，如果读取缓存没找到，就读数据库，**在读的时候把缓存回写**。还是可能会发生不一致，但是概率很小，比如清除缓存的时候失败。解决方案：缓存实效时间的设置。

- **先写缓存，再更新数据库**，可能导致缓存写成功，但是写数据库的时候响应失败，下次读取缓存会**脏读**， 而写并发写会造成缓存更新不是最新的，这个方式是完全错误的

- 为什么不能**先写数据库再更新缓存**呢，而是要清除缓存呢，这种做法最大的问题就是两个并发的**写操作**导致脏数据。 如果有两个thread对数据进行更新，可能导致并不是最新的缓存被更新了，无法保证缓存更新的是不是最新的。这个是错误的。

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/1587296490393.jpg" style="height:250px" />

- **先清除缓存，再更新数据库**。因为两个并发的**读和写操作**导致脏数据. 假如一个线程删除了缓存，更新数据库，此时正好有一个并发的**读操作**，读操作没有命中缓存后从数据库中取出老数据并且更新回缓存，这样缓存就不是应该更新的了，这个发生脏读的概率大, 而且随着并发量越大， 发生概率越大。

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/1587297956754.jpg" style="height:230px" />


#### 缓存穿透 
- 正常情况我们都是去查找存在的数据，如果请求去查找根本不存在的数据，每次请求都会打在数据库
- 可能带来的问题，如果有人对系统进行攻击，哪一个不存在的ID去查数据，可能击穿数据库
- 解决方法 **缓存空值** 把这些不存在的ID在缓存中设置null值，可能会缓存大量不存在的key
- **BloomFilter（布隆过滤器）**， 类似于一个Hash set, 白名单Key； 特点是占内存少，share bit 

##### BloomFilter 布隆过滤器
- 布隆过滤器是一个概率形数据结构，告诉某个东西一定不存在或者可能存在
- bit 数组, 生成不同的哈希值，如果有一位没有使用，说明这个key不存在，这样不同的key可以share bit哈希值，节省空间。
- 例如我们有两个key，分别是1,4,7 and 3,4,5， 这个时候如果有新的访问key bit 值是1,3,5 而 5并没不在一个valid的bit中，那么可以断定这个key不在bloomfiler 里

<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/bloom.jpg" style="height:250px" />
<img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/bloom2.jpg" style="height:250px" />

#### 缓存击穿 
- 在大并发系统中，大量请求一个key但是key在这个时候刚好失效，可能导致大量请求打到数据库上
- 可以在第一个查询数据的请求上使用**互斥锁**，这样等到第一个线程拿到了数据，然后做了缓存，其他线程就可以直接走缓存

#### 缓存雪崩
- 在某一个时刻大量缓存失效，比如你的缓存服务器挂了，或者如果缓存数据设置的过期时间是相同的，并且恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中大量请求会打到DB
- 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期
- 使用集群缓存，保证缓存的高可用 （Redis Cluster）备份节点
- 数据库访问限流 （锁，blocking queue）+
- 缓存持久化机制，尽快恢复

## Redis
- Redis是一个远程内存数据库，它可以key - value pair与**5种不同类型**的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘
- 通过各种机制，比如LRU，确保数据是热点数据
- String, list, set, zset, hash
- redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件
- 在Twitter中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合， Twist放在一个集合
#### Redis并发问题
- Redis是单线程模式，采取队列将并发定为串行
- 单线程不需要考虑锁，性能够用，内存查询快，平静不在于CPU单线程处理，而在于网络带宽这些





- 保证消息具有唯一编号，可以通过日志进行backtrace。
