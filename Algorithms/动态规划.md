# 动态规划：从入门到放弃


动态规划其实就是要找状态，以及状态之间的转移方程式

### 1. 斐波那契数列：

``` 
不用动态规划我们可以想到的是递归：
public int fib(int N) {
	if (N == 0) {
		return 0;
	} 
	else if (N == 1) {
	 	return 1;
  	} 
  	else {
   		return fib(N-1) + fib(N-2);
  	}
}  
```  
![avatar](https://images2017.cnblogs.com/blog/1281271/201711/1281271-20171120135408758-1412997977.png)

> 这样计算N-2的时候计算N-3，N-4，计算N-3 的时候计算了N-4，N-5所以层级越多，重复计算越多，复杂度为O(2^N)
> 使用动态规划可以记录下，当N = i时候的值，避免了不必要的计算 

```
动态规划：
public int fib(int N) {
	if (N == 0) return 0;
	if (N == 1) return 1;
	int[] dp = new int[N];
	dp[0] = 0;
	dp[1] = 1;
	for (int i = 2; i <= N; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	return dp[N];
}
```
### 2.Minimum Path Sum
- LC 64 https://leetcode.com/problems/minimum-path-sum/

> Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7

Explanation: Because the path 1→3→1→1→1 minimizes the sum.

```

- 其实这道题已经很直接了，我们要记录下每一个dp[i][j] 的最小sum，那么dp[grid.length][grid[0].length]就是最终的值
- 如何找每一个index最小的和呢，因为题目是从左上到右下，那么 dp[i][j] 最小值等于 grid[i][j] 加上 dp 数组左边或者上边的值其中小的哪一个，那么有 dp[i][j] = grid [i][j] + Math.min(dp[i-1][j],dp[i][j-1])
-  注意一些coner cases 如果是第一行，那没有上面只有左边的，同理第一列；
-  递推初始值，左上角 dp[i][j] = grid[i][j]
-  于是有以下：

```
public int minPathSum(int[][] grid) {
	int m = grid.length;
	int n = grid[0].length;
	int[][] dp = new int[m][n];
	for (int i = 0; i < m; i++) {
   		for (int j = 0; j < n; j++) {
			if (i == 0 && j == 0) {
				dp[i][j] = grid[i][j];
			} 
			else if (i == 0) {
				dp[i][j] = grid[i][j] + dp[i][j-1];
			}
			else if (j == 0) {
				dp[i][j] = grid[i][j] + dp[i-1][j];
			}
			else {
				dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
			}
		}
 	}
 	return dp[m-1][n-1];
}
```




