# 背包

## 0-1背包
- 有一个背包，他的容量为C(Capacity)。现在有n中不同的物品，其中每一件物品的重量为w(i)，价值为v(i)。问可以向这个背包中盛放哪些物品，**每个物品只可以选一次**，使得装满背包容量target基础上，物品的总价值最大 
- 不装item i ： dp[i][j] = dp[i-1][j]; 
- 装 item i ：dp[i][j] = dp[i-1][j - w[i]] + v[i]; 
- j - w[i] 是选取item i 之前重量的最大值，加上w[i]恰好达到 j, dp[i-1]是因为这是0-1背包，装i的时候之前不能有item i 在背包里

- 如果是完全背包，可以选择无限个item, 转移方程则为 dp[i][j] = dp[i][j - w[i]] + v[i]; 
的最大值

- 如果是找物品的个数，就简化了，不需要int[] v， 每次 dp[i-1][j - w[i-1]] + 1；相当于没有权重，每个物品价值是1；

```
	public int 01Knapsack(int[] w, int[] v, int target) {
		int n = w.length;
		int[][] dp = new int[n+1][target+1]; 
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= target; j++) {
				if (j < w[i-1]) { //容量为j的背包装不进item i
					dp[i][j] = dp[i-1][j];
				}
				else {
					dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1]);
				}
			}
		}
		return dp[n][target];
	}

```

## 完全背包
- 如果是完全背包，可以选择无限个item, 转移方程则为 dp[i][j] = dp[i][j - w[i]] + v[i]; 
的最大值

> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1

- 完全背包；找到达到target k, 最小的coin数量
- dp[i][j] = Math.min(dp[i-1][j], 1 + dp[i][j - coins[i-1]]);
- 找最小 注意初始化


```

    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] dp = new int[n+1][amount+1];
        for (int i = 0; i < dp.length; i++) {         
            Arrays.fill(dp[i], amount+1);            
        }
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++) {
                if (coins[i-1] > j) { //不选
                    dp[i][j] = dp[i-1][j];
                }
                else {
                    dp[i][j] = Math.min(dp[i-1][j], 1 + dp[i][j - coins[i-1]]);
                }
            }
        }
        if (dp[n][amount] == amount+1) {
            return -1;
        }
        return dp[n][amount];
    }
```