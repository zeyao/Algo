# 最小生成树：

 <img src="https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/WechatIMG8.jpeg" style="height:500px" />


## 1.Prime算法：

- Prime 算法在于用顶点进行贪心搜索
- 使用优先队列选择与所有已经选的node相邻的最近的边
- 在加入一个新的顶点时,这个顶点与其他所有已选顶点相连的边失效（会形成环）
- Prime因为要通过所有已选顶点临近的边选出最小值，所以适合顶点少边多的情况

 ![avatar](https://raw.githubusercontent.com/zeyao/TechNotes/master/Document/Screen%20Shot%202019-08-09%20at%201.40.58%20PM.png)
 
```   
public class Prime {
	
	public static class Connection {
		String node1;
		String node2;
		int length;
		
		public Connection(String node1, String node2, int length) {
			this.node1 = node1;
			this.node2 = node2;
			this.length = length;
		}
	}
	
	public static List<Connection> primMst(List<Connection> connectionList) {
		Comparator<Connection> compareFactor = new Comparator<Connection>() {
			public int compare(Connection o1, Connection o2) {
				return o1.length - o2.length;                 
			}
		};
		Set<String> markedNode = new HashSet<>();
		List<Connection> mst = new ArrayList<>();
		PriorityQueue<Connection> pq = new PriorityQueue<>(compareFactor);
		//所有边的优先队列
		String firstPickedNode = connectionList.get(0).node1;
		visit(connectionList, firstPickedNode, pq, markedNode);
		
		while (!pq.isEmpty()) {
			Connection minLenconnection = pq.poll();
			String node1 = minLenconnection.node1;
			String node2 = minLenconnection.node2;
			if (markedNode.contains(node1) && markedNode.contains(node2)) {
				continue;
				//失效的边
			}
			mst.add(minLenconnection);
			if (!markedNode.contains(node1)) {
				visit(connectionList, node1, pq, markedNode);
			}
			if (!markedNode.contains(node2)) {
				visit(connectionList, node2, pq, markedNode);
			}
		}		
		return mst;		
	}
	
	private static void visit(List<Connection> connectionList, String node, PriorityQueue<Connection> pq, Set<String> markedNode) {
		//标记顶点node并且将所有链接node未被标记的顶点都放入PQ
		markedNode.add(node);
		for (Connection connection : connectionList) {
			if (node.equals(connection.node1) && !markedNode.contains(connection.node2)) {
				pq.add(connection);
			}
			else if (node.equals(connection.node2) && !markedNode.contains(connection.node1)) {
				pq.add(connection);
			}
		}		
	}
	
	public static void main(String[] args) {
        Connection c1 = new Connection("A", "D", 1);
        Connection c2 = new Connection("A", "B", 3);
        Connection c3 = new Connection("D", "B", 3);
        Connection c4 = new Connection("B", "C", 1);
        Connection c5 = new Connection("C", "D", 1);
        Connection c6 = new Connection("E", "D", 6);
        Connection c7 = new Connection("C", "E", 5);
        Connection c8 = new Connection("C", "F", 4);
        Connection c9 = new Connection("E", "F", 2);
        List<Connection> graph = new ArrayList<>(Arrays.asList(c1, c2, c3, c4, c5, c6, c7, c8, c9));
        List<Connection> result = primMst(graph);
        for (Connection conn : result) {
            System.out.println(conn.node1 + "-" + conn.node2);
        }
    }	
}
 
```


## 1.Kruskal算法： 
- 和prime不同的是，KrusKal在所有的边来找最小距离的边，
- KrusKal先把所有边加入优先队列，依次进行判断
- 每次选择的边不能让图有环，通过判断要加入的边的两点是不是已经联通（如果已经联通，再去加上这条边，就有环啦）这里用到union find 的思想
- 如果新加入的边两顶点不曾已经联通，说明是有效的，加入mst
- 把所有有效边就是mst


``` 
public class Kruskal {

	public static class Connection {
		String node1;
		String node2;
		int length;

		public Connection(String node1, String node2, int length) {
			this.node1 = node1;
			this.node2 = node2;
			this.length = length;
		}
	}

	public static List<Connection> KrusKalMst(List<Connection> connectionList) {
		Comparator<Connection> compareFactor = new Comparator<Connection>() {
			public int compare(Connection o1, Connection o2) {
				return o1.length - o2.length;
			}
		};

		Map<String, String> unionMap = new HashMap<>();
		// union map for key with node name and value with the unionId
		for (Connection c : connectionList) {
			unionMap.put(c.node1, c.node1);
			unionMap.put(c.node2, c.node2);
		}

		List<Connection> mst = new ArrayList<>();
		PriorityQueue<Connection> pq = new PriorityQueue<>(compareFactor);
		// 对于边的优先队列
		for (Connection connection : connectionList) {
			pq.offer(connection);
		}
		while (!pq.isEmpty()) {
			Connection minLenconnection = pq.poll();
			String node1 = minLenconnection.node1;
			String node2 = minLenconnection.node2;
			if (union(node1, node2, unionMap)) {
				continue;
			}
			mst.add(minLenconnection);

		}
		return mst;
	}

	/**
	 * 判断两点是不是联通，用unionMap来记录每个node已经联通的node，如果两个node1
	 * node2任何AdjList有任何一个相同的node说明node1 node2是联通的
	 */
	private static String find(String node, Map<String, String> unionMap) {
		return unionMap.get(node);
	}

	private static boolean union(String p, String q, Map<String, String> unionMap) {
		String pId = find(p, unionMap);
		String qId = find(q, unionMap);
		if (pId.equals(qId)) {
			return true;
		}

		for (Map.Entry<String, String> entry : unionMap.entrySet()) {
			if (pId.equals(entry.getValue())) {
				entry.setValue(qId);
			}
		}
		return false;
	}
``` 
