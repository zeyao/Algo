# 图论概述：
- 图分为有向图和无向图
- 有向图：可达性
- 无向图：连通性

## 1. DSF：

- Dfs 

## 2. BFS：
- bfs 的模版在于用queue,先进先出
- 将起点加入queue，然后将起点拿出队列，并找寻所有的adjList,遍历并将相邻的node放进queue
- 这样永远是后放置的在队列尾，可以实现按层级搜索
- 如果要记录下BFS有多少层，则需要记录下int lastRoundBfsSize = queue.size(), 每出queue一个node，size - 1；（因为之后adjList入queue的会在记录下上一层queue.size() 之后，所以当之前的 lastRoundBfsSize = 0， 说明之前的一层全部出了队列，此时开始下一层；重复这个操作就可以

 
```
 int totalRoundBfs = 0;
 Queue<Integer> queue = new LinkedList<>();
 queue.add(1); // 初始化, can also be multiple  node add in queue
 while (queue.isEmpty()) {
 	int lastRoundBfsSize = queue.size();
 	while (lastRoundBfsSize > 0) {
 		Integer node = queue.poll();
 		List<Integer> adjList = node.findAdjList(node); //找寻临近的node
 		for (Integer adj : adjList) {
 			queue.offer(adj);
 		}
 		lastRoundBfsSize --;
 		//当该node所有的临近node都入了queue， lastRoundBfsSize --;
 	}
 	if (!queue.isEmpty()) {
 		totalRoundBfs ++;
 		//当lastRoundBfsSize == 0 说明所有上一层级入queue的node全部出队列了, 
 		//意味着当前层级的 bfs 全部搜索完全，该下一层级的了；
 	}
 }

```



# 无向图



## 3. 判定无向图有没有环

#### 1：Graph Valid Tree

- Lintcode 178 : https://www.lintcode.com/problem/graph-valid-tree/description

> 	 Description
	 Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), 
	 write a function to check whether these edges make up a valid tree.

``` 
Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] 
Output: true.

Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]
Output: false.

``` 
> 这道题其实就是在找无向图给定一些边，看看有没有环，没有环，就是valid tree

- DFS 解法： 从第一个node出发，用DFS，找寻相邻的node 放入一个AdjNodeList进行DFS
- 注意的是这里是无向图，边并没有规定指向方向，所以当我们寻找AdjLNodeList的时候，如果再int[i][0]找到了这个当前node的value 那么相邻的就是int[i][1], 反之 如果在int[i][1]找到了这个node的value 那么相邻的就是int[i][0]
- 已经使用过的边 mark成 visited，在寻找adjNodelist的时候不再去计算visted 过的边, 避免重复找寻计算同一个边[1,2]把自环当作环  1 -> 2  ， 2 -> 1 
- 用一个Set来记录已经visited 过的 node， 在这个DFS过程中，一旦发现访问了已经在visited set里面的node，说明有环


```
public class GraphValidTree {
	
boolean hasCycle = false;
    
    public boolean validTree(int n, int[][] edges) {
        if (edges.length == 0) return false;

        Set<Integer> visited = new HashSet<>();
        int[] edgeVistied = new int[edges.length];
        
        int first = edges[0][0];
        dfs(visited, first, edges, edgeVistied);
        if (hasCycle) {
            return false;
        }
        return visited.size() == n;
    }
    
    private void dfs(Set<Integer> visited, int node, int[][] edges, int[] edgeVistied) {
        visited.add(node);
        List<Integer> adjNodeList = findAdjNodeList(node, edges, edgeVistied);
        for (Integer adj : adjNodeList) {
            if (visited.contains(adj)) {
                hasCycle = true;
                return;
            }
            else if(!hasCycle){
                dfs(visited, adj, edges, edgeVistied);
            }
        }
    }
    
    private List<Integer> findAdjNodeList(int node, int[][] edges, int[] edgeVistied) {
        List<Integer> list = new ArrayList<>();
        for (int i = 0 ; i < edges.length; i++) {
            if (edges[i][0] == node && edgeVistied[i] == 0) {
                list.add(edges[i][1]);
                edgeVistied[i] = 1;
            }
            if (edges[i][1] == node && edgeVistied[i] == 0) {
                list.add(edges[i][0]);
                edgeVistied[i] = 1;
            }
        }
        return list;
    }
}

```




## 3. Union Find


#  有向图


## 1. 判定有向图有没有环
- 有向图要注意可达性，和无向图的不同在于，无向所有的node我们只需要一个Set来mark visited，一旦下一个节点曾经visited过，说明联通，有环。但是有向图不一样，联通不代表一定有环 比如2 -> 3 1 -> 3; 
- 第一种方法还是用DFS，但和无向图不一样的地方在于，有向图我们需要在每一次DFS，如果子节点不曾有环，需要把visited Set进行回溯
- 例如 1 - > 2 ; 1 - > 3 -> 2 第一个子节点2的深度搜索，结束后并没有环，这时候需要讲加进visited的2进行回溯移除
- 也就是说在有向图判断环的visited里，每一次只判断一条路径下，子节点是不是在visited里，重新进行任何新路径的深搜都需要进行回溯

### 例题 1: Course Schedule
- LeetCode 207 : https://leetcode.com/problems/course-schedule

> There are a total of n courses you have to take, labeled from 0 to n-1.

> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

``` 
Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.
             

Input: 4  [[2,0],[1,0],[3,1],[3,2],[1,3]]
Output: false
             
``` 

- DFS + 回溯 做法：

```
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites.length == 0) return true;
        
        //有向图有没有环
        //和无向图不同的是，不一定visited又一次被visited就说明有环
        //判断一次DFS，当前的node为顶点，顶点以下如果visited到顶点说明有环，但DFS结束到顶点，这个visited回溯成之前的样子
        //也就是说每一条DFS路径需要有一个visited记录，并且进行回溯
        
        Set<Integer> visitedPrequistiesSet = new HashSet<>();
        Set<Integer> pathVisited = new HashSet<>();
        
        int node = prerequisites[0][0];       
        boolean canFinishFlag = dfs(visitedPrequistiesSet, prerequisites, node, pathVisited);
        if (!canFinishFlag) return false;
        return true;
    }
    
    private boolean dfs(Set<Integer> visitedPrequistiesSet, int[][] prerequisites, Integer currentNode, Set<Integer> pathVisited) {
        pathVisited.add(currentNode);
        List<Integer> adjList = findAdj(prerequisites, currentNode, visitedPrequistiesSet);
        for (Integer adj : adjList) {
            if (pathVisited.contains(adj)) {
                return false;
            }
            boolean canFinishFlag = dfs(visitedPrequistiesSet, prerequisites, adj, pathVisited);
            if (!canFinishFlag) {
                return false;
            }
        }
        pathVisited.remove(currentNode);
        return true;
    }
    
    private List<Integer> findAdj(int[][] prerequisites, Integer currentNode, Set<Integer> visitedPrequistiesSet) {
        List<Integer> adjList = new ArrayList<>();
        for (int i = 0 ; i < prerequisites.length; i++) {
            if (!visitedPrequistiesSet.contains(i)) {
                if (prerequisites[i][0] == currentNode) {
                    adjList.add(prerequisites[i][1]);
                    visitedPrequistiesSet.add(i);
                }
            }
        }
        return adjList;
    }
  
```

## 1. 拓扑排序