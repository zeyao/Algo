
# 无向图

## 1. DSF：

- Dfs 

## 2. BFS：
- Bfs

## 3. 判定无向图有没有环

#### 1：Graph Valid Tree

- Lintcode 178 : https://www.lintcode.com/problem/graph-valid-tree/description

> 	 Description
	 Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), 
	 write a function to check whether these edges make up a valid tree.

``` 
Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] 
Output: true.

Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]
Output: false.

``` 
> 这道题其实就是在找无向图给定一些边，看看有没有环，没有环，就是valid tree

- DFS 解法： 从第一个node出发，用DFS，找寻相邻的node 放入一个AdjNodeList进行DFS
- 注意的是这里是无向图，边并没有规定指向方向，所以当我们寻找AdjLNodeList的时候，如果再int[i][0]找到了这个当前node的value 那么相邻的就是int[i][1], 反之 如果在int[i][1]找到了这个node的value 那么相邻的就是int[i][0]
- 已经使用过的边 mark成 visited，在寻找adjNodelist的时候不再去计算visted 过的边, 避免重复找寻计算同一个边[1,2]把自环当作环  1 -> 2  ， 2 -> 1 
- 用一个Set来记录已经visited 过的 node， 在这个DFS过程中，一旦发现访问了已经在visited set里面的node，说明有环


```
public class GraphValidTree {
	
boolean hasCycle = false;
    
    public boolean validTree(int n, int[][] edges) {
        if (edges.length == 0) return false;

        Set<Integer> visited = new HashSet<>();
        int[] edgeVistied = new int[edges.length];
        
        int first = edges[0][0];
        dfs(visited, first, edges, edgeVistied);
        if (hasCycle) {
            return false;
        }
        return visited.size() == n;
    }
    
    private void dfs(Set<Integer> visited, int node, int[][] edges, int[] edgeVistied) {
        visited.add(node);
        List<Integer> adjNodeList = findAdjNodeList(node, edges, edgeVistied);
        for (Integer adj : adjNodeList) {
            if (visited.contains(adj)) {
                hasCycle = true;
                return;
            }
            else if(!hasCycle){
                dfs(visited, adj, edges, edgeVistied);
            }
        }
    }
    
    private List<Integer> findAdjNodeList(int node, int[][] edges, int[] edgeVistied) {
        List<Integer> list = new ArrayList<>();
        for (int i = 0 ; i < edges.length; i++) {
            if (edges[i][0] == node && edgeVistied[i] == 0) {
                list.add(edges[i][1]);
                edgeVistied[i] = 1;
            }
            if (edges[i][1] == node && edgeVistied[i] == 0) {
                list.add(edges[i][0]);
                edgeVistied[i] = 1;
            }
        }
        return list;
    }
}

```



## 3. 拓扑排序

## 4. Union Find


#  有向图


